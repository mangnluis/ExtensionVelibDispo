/**
 * Module d'analyse et de d√©cision pour les trajets V√©lib
 */

/**
 * Effectue une analyse compl√®te d'un trajet potentiel en V√©lib
 * 
 * @param {Object} origin - {lat, lng} du point de d√©part 
 * @param {Object} destination - {lat, lng} du point d'arriv√©e
 * @returns {Promise<Object>} - R√©sultat de l'analyse
 */
function analyzeVelibJourney(origin, destination) {
    // 1. Calcul de la distance directe
    const directDistance = calculateHaversineDistance(
      origin.lat, origin.lng,
      destination.lat, destination.lng
    );
    
    // 2. V√©rification pr√©liminaire de la distance
    if (directDistance < 500) {
      return Promise.resolve({
        recommendation: false,
        reason: "La distance est trop courte, la marche est pr√©f√©rable.",
        alternative: {
          mode: "üö∂‚Äç‚ôÇÔ∏è Marche",
          duration: directDistance / 1.2, // Vitesse moyenne 1.2 m/s
          durationText: formatDuration(directDistance / 1.2),
          description: "Profitez d'une courte marche de quelques minutes."
        }
      });
    }
    
    // 3. R√©cup√©rer les stations de d√©part √† proximit√©
    return getNearbyVelibStations(origin)
      .then(departureStations => {
        // V√©rifier que departureStations est bien un tableau
        if (!departureStations || !Array.isArray(departureStations)) {
          console.error("Les stations de d√©part ne sont pas un tableau valide:", departureStations);
          departureStations = [];
        }
        
        // S'il n'y a pas de stations pr√®s du point de d√©part
        if (departureStations.length === 0) {
          return getTransportAlternatives(origin, destination)
            .then(alternative => ({
              recommendation: false,
              reason: "Aucune station V√©lib √† proximit√© de votre point de d√©part.",
              alternative: alternative || {
                mode: "üö∂‚Äç‚ôÇÔ∏è Marche",
                durationText: "Variable",
                description: "Les stations V√©lib sont trop √©loign√©es. La marche ou les transports en commun sont recommand√©s."
              }
            }));
        }
        
        // Filtrer les stations avec des v√©los disponibles
        const availableStations = departureStations.filter(s => s.bikes > 0);
        
        if (availableStations.length === 0) {
          return getTransportAlternatives(origin, destination)
            .then(alternative => ({
              recommendation: false,
              reason: "Aucun v√©lo disponible dans les stations √† proximit√©.",
              alternative: alternative || {
                mode: "üö∂‚Äç‚ôÇÔ∏è Marche ou transport en commun",
                durationText: "Variable",
                description: "Aucun v√©lo disponible actuellement. R√©essayez plus tard ou optez pour une alternative."
              }
            }));
        }
        
        // 4. R√©cup√©rer les stations d'arriv√©e √† proximit√©
        return getNearbyVelibStations(destination)
          .then(arrivalStations => {
            // V√©rifier que arrivalStations est bien un tableau
            if (!arrivalStations || !Array.isArray(arrivalStations)) {
              console.error("Les stations d'arriv√©e ne sont pas un tableau valide:", arrivalStations);
              arrivalStations = [];
            }
            
            // S'il n'y a pas de stations pr√®s du point d'arriv√©e
            if (arrivalStations.length === 0) {
              return getTransportAlternatives(origin, destination)
                .then(alternative => ({
                  recommendation: false,
                  reason: "Aucune station V√©lib √† proximit√© de votre destination.",
                  alternative: alternative || {
                    mode: "üö∂‚Äç‚ôÇÔ∏è Marche ou transport en commun",
                    durationText: "Variable",
                    description: "Les stations V√©lib sont trop √©loign√©es de votre destination."
                  }
                }));
            }
            
            // Filtrer les stations avec des emplacements disponibles
            const availableDocks = arrivalStations.filter(s => s.docks > 0);
            
            if (availableDocks.length === 0) {
              return getTransportAlternatives(origin, destination)
                .then(alternative => ({
                  recommendation: false,
                  reason: "Aucun emplacement disponible dans les stations √† proximit√© de votre destination.",
                  alternative: alternative || {
                    mode: "üö∂‚Äç‚ôÇÔ∏è Marche ou transport en commun",
                    durationText: "Variable",
                    description: "Toutes les stations pr√®s de votre destination sont pleines. R√©essayez plus tard."
                  }
                }));
            }
            
            // 5. Calculer l'itin√©raire √† v√©lo entre origine et destination
            return calculateRoute(origin, destination, 'cycling-regular')
              .then(bikeRoute => {
                // S'assurer que bikeRoute a les propri√©t√©s n√©cessaires
                if (!bikeRoute || !bikeRoute.duration || !bikeRoute.distance) {
                  throw new Error("Impossible de calculer l'itin√©raire √† v√©lo.");
                }
                
                // 6. Calculer l'itin√©raire √† pied et en transport en commun pour comparaison
                return getTransportAlternatives(origin, destination)
                  .then(alternative => {
                    // 7. Prendre une d√©cision
                    const velibTime = bikeRoute.duration + 
                      availableStations[0].walkDuration + 
                      availableDocks[0].walkDuration + 
                      300; // 5min buffer pour prendre/d√©poser le v√©lo
                    
                    const shouldTakeVelib = alternative ? 
                      velibTime < alternative.duration * 1.2 : // 20% buffer
                      true;
                    
                    if (shouldTakeVelib) {
                      // Trier les stations par praticit√©
                      const bestDepartureStations = availableStations
                        .sort((a, b) => (a.walkDuration + (a.bikes < 3 ? 300 : 0)) - 
                                        (b.walkDuration + (b.bikes < 3 ? 300 : 0)))
                        .slice(0, 3);
                      
                      const bestArrivalStations = availableDocks
                        .sort((a, b) => (a.walkDuration + (a.docks < 3 ? 300 : 0)) - 
                                        (b.walkDuration + (b.docks < 3 ? 300 : 0)))
                        .slice(0, 3);
                      
                      return {
                        recommendation: true,
                        reason: `Le trajet en V√©lib est plus rapide (${formatDuration(bikeRoute.duration)} de v√©lo + ${formatDuration(availableStations[0].walkDuration + availableDocks[0].walkDuration)} de marche).`,
                        departureStations: bestDepartureStations,
                        arrivalStations: bestArrivalStations,
                        route: bikeRoute,
                        alternative: alternative
                      };
                    } else {
                      return {
                        recommendation: false,
                        reason: `Une alternative plus rapide existe.`,
                        alternative: alternative || {
                          mode: "üö∂‚Äç‚ôÇÔ∏è Marche",
                          duration: directDistance / 1.2,
                          durationText: formatDuration(directDistance / 1.2),
                          description: "La marche ou les transports en commun semblent plus pratiques pour ce trajet."
                        }
                      };
                    }
                  });
              });
          });
      })
      .catch(error => {
        console.error("Erreur dans analyzeVelibJourney:", error);
        // Retourner un r√©sultat d'erreur format√©
        return {
          recommendation: false,
          reason: "Erreur lors de l'analyse: " + (error.message || "Veuillez r√©essayer."),
          alternative: {
            mode: "üö∂‚Äç‚ôÇÔ∏è Marche ou transport en commun",
            durationText: "Non disponible",
            description: "Une erreur s'est produite. Veuillez r√©essayer ou opter pour une alternative."
          }
        };
      });
}
